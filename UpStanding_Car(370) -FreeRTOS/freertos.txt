-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Q:这个唤醒机制是什么意思，比如我有ABC分别为高中低优先级，B可以被中断唤醒，如果A进入阻塞，轮到B，如果B没有被唤醒直接轮到C是吗
A:是的，具体问千问

//等待中断中的任务通知
/*只要 B 还在 ulTaskNotifyTake() 里阻塞等待（没收到通知），它的状态就是 Blocked，调度器根本不会考虑它*/
while (ulTaskNotifyTake(pdTRUE, portMAX_DELAY) != pdPASS)
 {
}

 //MPU外部中断处理
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)  
{   
    if(GPIO_Pin == MPU_INT_Pin)  
    {  
		//任务通知唤醒 
		if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
        {
            static BaseType_t xHigherPriorityTaskWoken;
            vTaskNotifyGiveFromISR(INS_task_local_handler, &xHigherPriorityTaskWoken);
            portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
        }
    }  
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Q:我知道这个原理，但我不知道这怎么就保护Target_Speed、Target_turn，不是if里所有的都保护了吗?

A:	该互斥锁判断的核心是尝试获取互斥量，成功后进入临界区
	比如 Control 任务中，“读取传感器数据”→“执行 PID 计算”→“读取 Target_Speed”→“控制电机”，这些代码都放进了临界区：(都在if互斥锁判断里)
	虽然 “读取传感器”“PID 计算” 是 Control 任务私有操作，不需要保护；
	但因为其中包含了 “读取 Target_Speed” 这个需要保护的操作，为了代码简洁，直接把整个控制流程放进临界区（反正放进临界区也不会有副作用，还能避免遗漏保护）；
	当然，你也可以只把 “读取 Target_Speed” 这一行代码放进临界区，效果完全一样，只是代码会更零散。
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------










